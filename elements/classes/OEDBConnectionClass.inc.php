<?php
/**
 * OEDBConnectionClass.inc.php
 * 
 * Establishes connection to a database, serves as Data Abstraction Layer
 * 
 * OpenEyes is licensed by Moorfields Eye Hospital NHS Foundation Trust (the "Licensor") under version 3 of 
 * the GNU General Public Licence (GPL), and version 1 of the Open Eyes Proprietary Licence (OEPL).
 * 
 * You can choose the licence that most suits your intended use of OpenEyes. If you wish to contribute to the OpenEyes open source project
 * or incorporate OpenEyes into your own open source project, version 3 of the GNU General Public Licence or any later version shall apply.
 * If you wish to use OpenEyes for commercial purposes, the terms of the OpenEyes Proprietary Licence shall apply; 
 * 
 * A plain text version of the OpenEyes Proprietary Licence is distributed with this software. The Licensor reserves the right to publish
 * revised and/or new versions of the OpenEyes Proprietary Licence from time to time. Each version will be given a distinguishing version number.
 * 
 * When using OpenEyes in your commercial application, or open source application you are required to distribute your chosen 
 * licence (GPLv3 or OEPLv1) with your application and ensure the following acknowledgement is contained within both the program 
 * and in any userÕs manual.
 * 
 * 		"This software uses elements of OpenEyes open source software (see http://www.openeyes.org.uk) Open Eyes is used and may only be 
 * 		used under the [GPL/OEPL] version [insert version number]"
 * 
 * @author Bill Aylward <bill.aylward@mac.com>
 * @license http://www.gnu.org/licenses/gpl.html GPLv3.0
 * @license http://www.openeyes.org.uk/licenses/oepl-1.0.html OEPLv1.0
 * @version 1.1
 * Modification date: 16th December 2010
 * @copyright Copyright (c) 2010 OpenEyes
 * @package Base
 */

/**
 * Import OpenEyes class files
 */
require_once ('OEBaseClasses.inc.php');

/**
 * OEDBConnectionClass interface
 * 
 * @package Base
 */
interface iOEDBConnection
{
	// Connect functions
	public function isConnected();				// Returns boolean indicating successful connection
	
	// Query functions
	public function execute($query);			// Executes an SQL query, returns TRUE is successful. Adds query to audit trail
	public function resultArray();				// Returns a multidimensional array with each row an object field->value, or false if no results
	public function errorMessage();				// Returns an message containing the last error message
	public function recordCount();				// Returns the number of records returned by the last executed query
	public function firstResult();				// Returns first member of result set, or false if no results
	public function fieldCount();				// Returns the number of fields in the query return
	public function insertID();					// returns the ID generated by an INSERT on a table with an AUTO_INCREMENT primary key
	public function escapeString($string);		// Trims and applies real escape function to passed string
	public function cleanString($string);		// Trims and escapes the string
	
	// Transaction functions
	public function startTransaction();			// Start transaction
	public function commitTransaction();		// Commit transaction	
	public function rollbackTransaction();		// Rollback transaction
	
	// Information functions
	public function tableInfo($table);			// Returns information about fields in the table
}

/**
 * Establishes connection to a database, serves as Data Abstraction Layer
 * 
 * @package Base
 * @property mysqli $this->dbc Connection to database
 * @property string $this->errorMessage Error message
 * @property boolean $this->isConnected Flag indicating successful connection
 * @property array $this->resArray Results of query
 * @property integer $this->recCount Number of records returned
 * @property integer $this->fldCount Number of fields in table
 * @property integer $this->insID ID of most recent inserted record
 */
class OEDBConnection extends OEObject implements iOEDBConnection
{
	/**
	 * Constructor
	 * 
	 * @param integer $_database Database to connect to
	 */
	public function __construct($_database)
	{
		// Connect to a database
		switch ($_database)
		{
			case OEDatabase::main:
				$this->dbc = new mysqli(MAIN_DB_HOST, MAIN_DB_USER, MAIN_DB_PASSWORD, MAIN_DB_NAME);
				break;
			case OEDatabase::rbac:
				$this->dbc = new mysqli(RBAC_DB_HOST, RBAC_DB_USER, RBAC_DB_PASSWORD, RBAC_DB_NAME);
				break;
			case OEDatabase::complog:
				$this->dbc = new mysqli(COMPLOG_DB_HOST, COMPLOG_DB_USER, COMPLOG_DB_PASSWORD, COMPLOG_DB_NAME);
				break;
		}
		
		if ($this->dbc->connect_error)
		{
			$this->errorMessage = $this->dbc->connect_error;
			$this->isConnected = false;
		}
		else
		{
			// Successful connection, initialise properties
			$this->errorMessage = "";
			$this->isConnected = true;
		}
		
		// Set other properties
		$this->resArray = array();
		$this->recCount = 0;
		$this->fldCount = 0;
		$this->insID = 0;
		
		// Cannot continue if database not connected
		if (!$this->isConnected()) $this->redirect(NO_DATABASE_REDIRECT_SCRIPT);
	}

	/**
	 * Destructor
	 */
	public function __destruct()
	{
		// Close database connection
		if ($this->isConnected)
		{
			$this->dbc->close();
		}
	}
	
	/**
	 * Executes query
	 * 
	 * @param string $query SQL query to be executed
	 * @return boolean
	 */
	public function execute($query)
	{
		// Return flag
		$returnFlag = false;
		
		// Reset properties
		$this->resArray = array();
		$this->recCount = 0;
		$this->fldCount = 0;
		$this->insID = 0;
		$this->errorMessage = "";
		
		// SELECT
		if ($this->isSELECT($query))
		{
			$result = $this->dbc->query($query);
			if ($result)
			{
				$this->recCount = $result->num_rows;
				$this->fldCount = $result->field_count;
	
				// Put output into multidimensional array
				/**
				 * @todo handle maximum select limit better
				 */
				if ($this->recCount < 10000)
				{
					$i = 0;
					while ($row = $result->fetch_object())
					{
						$this->resArray[] = $row;
					}
				}
				else
				{
					$this->errorMessage = "Maximum size of SELECT result set exceeded";
				}
			
				// Free result set
				$result->close();
				
				$returnFlag = true;
			}
			else
			{
				$this->errorMessage = $this->dbc->error;
				$returnFlag = false;
			}
		}
		// NON-SELECT query
		else
		{
			$result = $this->dbc->query($query);
			if ($result)
			{
				$this->recCount = $this->dbc->affected_rows;
				$this->insID = $this->dbc->insert_id;
				
				$returnFlag = true;
			}
			else
			{
				$this->errorMessage = $this->dbc->error;
				$returnFlag = false;
			}
		}

		// Append to audit trail
		$user_id = isset($_SESSION['userId'])?$_SESSION['userId']:0;
		$strippedQuery = $this->cleanString((preg_replace('/\s\s+/', ' ', $query)));
		$q = "INSERT INTO audittrail (audittrail_id, datetime, user_id, scriptname, query) VALUES (NULL, NOW(), $user_id, '".$_SERVER['SCRIPT_NAME']."', '$strippedQuery')";	
		$this->dbc->query($q);
		
		return $returnFlag;
	}
	
	/**
	 * Returns result array
	 * 
	 * @return mixed Result array or false if no results
	 */
	public function resultArray()
	{
		if (count($this->resArray) > 0)
		{
			return $this->resArray;
		}
		else
		{
			return false;
		}
	}
	
	/**
	 * Returns first result
	 * 
	 * @return mixed first item of result array or false if no results
	 */
	public function firstResult()
	{
		if (count($this->resArray) > 0)
		{
			return $this->resArray[0];
		}
		else
		{
			return false;
		}
	}
	
	/**
	 * Returns true if database was successfully connected
	 * 
	 * @return boolean
	 */
	public function isConnected()
	{
		return $this->isConnected;
	}
	
	/**
	 * Returns error message
	 * 
	 * @return string
	 */
	public function errorMessage()
	{
		return $this->errorMessage;
	}
	
	/**
	 * Returns number of records retrieved
	 * 
	 * @return integer
	 */
	public function recordCount()
	{
		return $this->recCount;
	}
	
	/**
	 * Returns number of fields in table
	 * 
	 * @return integer
	 */
	public function fieldCount()
	{
		return $this->fldCount;
	}
	
	/**
	 * Returns ID of most recent inserted record
	 * 
	 * @return integer
	 */
	public function insertID()
	{
		return $this->insID;
	}
	
	/**
	 * Applies real escape function to passed string
	 * 
	 * @param string $string Input string
	 * @return string
	 */
	public function escapeString($string)
	{
		if ($this->isConnected)
		{
			return $this->dbc->real_escape_string($string);
		}
		else
		{
			return $string;
		}
	}
	
	/**
	 * Trims and applies real escape function to passed string
	 * 
	 * @param string $string Input string
	 * @return string
	 */
	public function cleanString($string)
	{
		if ($this->isConnected)
		{
			return $this->dbc->real_escape_string(trim($string));
		}
		else
		{
			return $string;
		}
	}
	
	/**
	 * Starts a transaction
	 */
	public function startTransaction()
	{		
		// Turn off auto-commit
		$this->dbc->autocommit(FALSE);
		
		// Establish stack for any $_SESSION variables that are altered during transaction
		if (isset($_SESSION['transactionStack']))
		{
			$_SESSION['transactionStack'] = NULL; 
			unset($_SESSION['transactionStack']);
		}
		$_SESSION['transactionStack'] = new StdClass;
	}
	
	/**
	 * Commits the current transaction
	 */
	public function commitTransaction()
	{		
		// Commit changes
		$this->dbc->commit();
		
		// Iterate through transaction stack committing changes
		foreach($_SESSION['transactionStack'] as $key => $value)
		{
			$_SESSION[$key] = $value;
		}
		
		// Delete stack
		$_SESSION['transactionStack'] = NULL; 
		unset($_SESSION['transactionStack']);		
	}

	/**
	 * Rollbacks the current transaction
	 */
	public function rollbackTransaction()
	{		
		// Roolback changes
		$this->dbc->rollback();
		
		// Delete stack
		$_SESSION['transactionStack'] = NULL; 
		unset($_SESSION['transactionStack']);
	}
	
	/**
	 * Returns array containing information about a table
	 * 
	 * @param string $table Name of the table
	 * @return array Array containing OEField objects
	 */
	public function tableInfo($table)
	{
		// Array to hold field objects
		$fields = array(); 
		
		// Get columes from table
		$q = "SHOW COLUMNS FROM $table";	
		$r = $this->dbc->query($q);
		
		// Check for returned rows
		$num = $r->num_rows;
		if ($num > 0)
		{
			// Loop through result set
			while ($row = $r->fetch_object())
			{
				// Instantiate new Field object for each row
				$field = new OEField();
				$field->name = $row->Field;
			
				// ENUM (do this test first since enums may have values containing int, char etc)
				if (stripos($row->Type, "enum") !== FALSE)
				{
					$field->type = OEFieldType::enum;
					$field->length = intval(preg_replace("/\D/", "", $row->Type));
					
					if (preg_match('/enum.(.*)./', $row->Type, $match))
					{
						// Get individual options into array
						$opts = explode(',', $match[1]);
						
						// Go through each item , and 
						$result = array();
						$maxlen = 0;
						
						foreach ($opts as $item)
						{
							// Remove quotation marks
							$str = substr($item, 1, strlen($item)-2);
							
							// Record maximum length
							$len = strlen($str);
							$maxlen = $len > $maxlen?$len:$maxlen;
	
							// Add string to array
							$result[] = $str;
						}
						
						$field->length = $maxlen;
						$field->enumArray = $result;
					}
				}
				
				// CHAR() or VARCHAR()
				else if (stripos($row->Type, "char") !== FALSE)
				{
					$field->type = OEFieldType::char;
					$field->length = intval(preg_replace("/\D/", "", $row->Type));
				}

				// TINYTEXT or TEXT
				else if (stripos($row->Type, "text") !== FALSE)
				{
					$field->type = OEFieldType::text;
					$field->length = intval(preg_replace("/\D/", "", $row->Type));
				}				

				// BOOL - MySQL silently converts BOOL to TINYINT
				else if (stripos($row->Type, "tinyint") !== FALSE)
				{
					$field->length = intval(preg_replace("/\D/", "", $row->Type));
					if ($field->length == 1)
					{
						$field->type = OEFieldType::bool;
					}
					else
					{
						$field->type = OEFieldType::int;						
					}
				}

				// Any INT eg SMALLINT (MySQL silently converts BOOL to TINYTEXT
				else if (stripos($row->Type, "int") !== FALSE)
				{
					$field->type = OEFieldType::int;
					$field->length = intval(preg_replace("/\D/", "", $row->Type));
				}
				
				// FLOAT
				else if (stripos($row->Type, "float") !== FALSE)
				{
					$field->type = OEFieldType::float;
					//$field->length = intval(preg_replace("/\D/", "", $row->Type));
					$field->length = 8;
				}
				
				// DECIMAL
				else if (stripos($row->Type, "decimal") !== FALSE)
				{
					$field->type = OEFieldType::decimal;
					//$field->length = intval(preg_replace("/\D/", "", $row->Type));
					$field->length = 10;
				}
								
				// DATE
				else if (stripos($row->Type, "date") !== FALSE)
				{
					$field->type = OEFieldType::date;
					$field->length = intval(preg_replace("/\D/", "", $row->Type));
				}
								
				// Default values
				$field->default = $row->Default;
				
				// Add to array, with field name as key
				$fields[$field->name] = $field;
				}
		}
					
		// Return array
		return $fields;
	}
	
	/**
	 * Returns boolean if query is an SQL SELECT
	 * 
	 * @param string $query SQL query
	 * @return boolean
	 */
	private function isSELECT($query)
	{
		// NB === operator used to avoid boolean false and 0 confusion
		return (stripos(trimText($query),"SELECT") === 0);
	}
}
?>